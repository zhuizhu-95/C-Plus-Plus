<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms_in_C++: range_queries::perSegTree Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algorithms_in_C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Set of algorithms implemented in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d28/classrange__queries_1_1per_seg_tree.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../da/d66/classrange__queries_1_1per_seg_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">range_queries::perSegTree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Range query here is range sum, but the code can be modified to make different queries like range max or min.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for range_queries::perSegTree:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d47/classrange__queries_1_1per_seg_tree__coll__graph.svg" width="100%" height="450"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac83bcabf5a8db8b0d8d156a4c1bcd4c3" id="r_ac83bcabf5a8db8b0d8d156a4c1bcd4c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac83bcabf5a8db8b0d8d156a4c1bcd4c3">construct</a> (const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; int64_t &gt; &amp;<a class="el" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a>)</td></tr>
<tr class="memdesc:ac83bcabf5a8db8b0d8d156a4c1bcd4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing the segment tree with the values in the passed vector. Returned root pointer is pushed in the pointers vector to have access to the original version if the segment tree is updated.  <br /></td></tr>
<tr class="separator:ac83bcabf5a8db8b0d8d156a4c1bcd4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87494e6cf012d28c4f5b9d1c15f9c5d" id="r_af87494e6cf012d28c4f5b9d1c15f9c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af87494e6cf012d28c4f5b9d1c15f9c5d">update</a> (const uint32_t &amp;l, const uint32_t &amp;r, const int64_t &amp;value)</td></tr>
<tr class="memdesc:af87494e6cf012d28c4f5b9d1c15f9c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doing range update by passing the left and right indexes of the range as well as the value to be added.  <br /></td></tr>
<tr class="separator:af87494e6cf012d28c4f5b9d1c15f9c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad484002bcb701820d55f32ea5d525571" id="r_ad484002bcb701820d55f32ea5d525571"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad484002bcb701820d55f32ea5d525571">query</a> (const uint32_t &amp;l, const uint32_t &amp;r, const uint32_t &amp;version)</td></tr>
<tr class="memdesc:ad484002bcb701820d55f32ea5d525571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Querying the range from index l to index r, getting the sum of the elements whose index x satisfies l&lt;=x&lt;=r.  <br /></td></tr>
<tr class="separator:ad484002bcb701820d55f32ea5d525571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4e431f3e09c274ecd7d2d58dcb865" id="r_a0fe4e431f3e09c274ecd7d2d58dcb865"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fe4e431f3e09c274ecd7d2d58dcb865">size</a> ()</td></tr>
<tr class="memdesc:a0fe4e431f3e09c274ecd7d2d58dcb865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the number of versions after updates so far which is equal to the size of the pointers vector.  <br /></td></tr>
<tr class="separator:a0fe4e431f3e09c274ecd7d2d58dcb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0cec4b77d264521717cf9b0482c45817" id="r_a0cec4b77d264521717cf9b0482c45817"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cec4b77d264521717cf9b0482c45817">newKid</a> (<a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;curr)</td></tr>
<tr class="memdesc:a0cec4b77d264521717cf9b0482c45817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a new node with the same values of curr node.  <br /></td></tr>
<tr class="separator:a0cec4b77d264521717cf9b0482c45817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7f57935b3bb9446f11c239fd89ae79" id="r_ace7f57935b3bb9446f11c239fd89ae79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace7f57935b3bb9446f11c239fd89ae79">lazy</a> (const uint32_t &amp;i, const uint32_t &amp;j, <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;curr)</td></tr>
<tr class="memdesc:ace7f57935b3bb9446f11c239fd89ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is some value to be propagated to the passed node, value is added to the node and the children of the node, if exist, are copied and the propagated value is also added to them.  <br /></td></tr>
<tr class="separator:ace7f57935b3bb9446f11c239fd89ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3f2465a7c5803a1ff16c5378bcc5e4" id="r_a6d3f2465a7c5803a1ff16c5378bcc5e4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">construct</a> (const uint32_t &amp;i, const uint32_t &amp;j)</td></tr>
<tr class="memdesc:a6d3f2465a7c5803a1ff16c5378bcc5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing the segment tree with the early passed vector. Every call creates a node to hold the sum of the given range, set its pointers to the children, and set its value to the sum of the children's values.  <br /></td></tr>
<tr class="separator:a6d3f2465a7c5803a1ff16c5378bcc5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24487eda25123bc4d112e8430821a6c6" id="r_a24487eda25123bc4d112e8430821a6c6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24487eda25123bc4d112e8430821a6c6">update</a> (const uint32_t &amp;i, const uint32_t &amp;j, const uint32_t &amp;l, const uint32_t &amp;r, const int64_t &amp;value, <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;curr)</td></tr>
<tr class="memdesc:a24487eda25123bc4d112e8430821a6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doing range update, checking at every node if it has some value to be propagated. All nodes affected by the update are copied and propagation value is added to the leaf of them.  <br /></td></tr>
<tr class="separator:a24487eda25123bc4d112e8430821a6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ae4b1835e5e8aec32f68c5059ed4d4" id="r_ae8ae4b1835e5e8aec32f68c5059ed4d4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">query</a> (const uint32_t &amp;i, const uint32_t &amp;j, const uint32_t &amp;l, const uint32_t &amp;r, <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;curr)</td></tr>
<tr class="memdesc:ae8ae4b1835e5e8aec32f68c5059ed4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Querying the range from index l to index r, checking at every node if it has some value to be propagated. Current node's value is returned if its range is completely inside the wanted range, else 0 is returned.  <br /></td></tr>
<tr class="separator:ae8ae4b1835e5e8aec32f68c5059ed4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6f5b36111f90807a9fdf6bbca04f535e" id="r_a6f5b36111f90807a9fdf6bbca04f535e"><td class="memItemLeft" align="right" valign="top"><a id="a6f5b36111f90807a9fdf6bbca04f535e" name="a6f5b36111f90807a9fdf6bbca04f535e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b> = 0</td></tr>
<tr class="separator:a6f5b36111f90807a9fdf6bbca04f535e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eac9cf0613dfc8e2b0195009dd5c9d5" id="r_a1eac9cf0613dfc8e2b0195009dd5c9d5"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a> {}</td></tr>
<tr class="memdesc:a1eac9cf0613dfc8e2b0195009dd5c9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements/leaf nodes in the segment tree  <br /></td></tr>
<tr class="separator:a1eac9cf0613dfc8e2b0195009dd5c9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff495d2f389b4aaa54449c26c6078f3" id="r_a8ff495d2f389b4aaa54449c26c6078f3"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a> {}</td></tr>
<tr class="separator:a8ff495d2f389b4aaa54449c26c6078f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Range query here is range sum, but the code can be modified to make different queries like range max or min. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac83bcabf5a8db8b0d8d156a4c1bcd4c3" name="ac83bcabf5a8db8b0d8d156a4c1bcd4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83bcabf5a8db8b0d8d156a4c1bcd4c3">&#9670;&#160;</a></span>construct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void range_queries::perSegTree::construct </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing the segment tree with the values in the passed vector. Returned root pointer is pushed in the pointers vector to have access to the original version if the segment tree is updated. </p>
<p>public methods that can be used directly from outside the class. They call the private functions that do all the work </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector whose values will be used to build the segment tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  200</span>    {</div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/empty.html">empty</a>()) {</div>
<div class="line"><span class="lineno">  202</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  203</span>        }</div>
<div class="line"><span class="lineno">  204</span>        n = <a class="code hl_variable" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a>();</div>
<div class="line"><span class="lineno">  205</span>        this-&gt;vec = <a class="code hl_variable" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a>;</div>
<div class="line"><span class="lineno">  206</span>        <span class="keyword">auto</span> root = <a class="code hl_function" href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">construct</a>(0, n - 1);</div>
<div class="line"><span class="lineno">  207</span>        <a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">push_back</a>(root);</div>
<div class="line"><span class="lineno">  208</span>    }</div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_a1eac9cf0613dfc8e2b0195009dd5c9d5"><div class="ttname"><a href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">range_queries::perSegTree::ptrs</a></div><div class="ttdeci">std::vector&lt; std::shared_ptr&lt; Node &gt; &gt; ptrs</div><div class="ttdoc">number of elements/leaf nodes in the segment tree</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:54</div></div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_a6d3f2465a7c5803a1ff16c5378bcc5e4"><div class="ttname"><a href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">range_queries::perSegTree::construct</a></div><div class="ttdeci">std::shared_ptr&lt; Node &gt; construct(const uint32_t &amp;i, const uint32_t &amp;j)</div><div class="ttdoc">Constructing the segment tree with the early passed vector. Every call creates a node to hold the sum...</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:106</div></div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_a8ff495d2f389b4aaa54449c26c6078f3"><div class="ttname"><a href="#a8ff495d2f389b4aaa54449c26c6078f3">range_queries::perSegTree::vec</a></div><div class="ttdeci">std::vector&lt; int64_t &gt; vec</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:57</div></div>
<div class="ttc" id="aempty_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/empty.html">std::vector::empty</a></div><div class="ttdeci">T empty(T... args)</div></div>
<div class="ttc" id="apush_back_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">std::vector::push_back</a></div><div class="ttdeci">T push_back(T... args)</div></div>
<div class="ttc" id="asize_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/size.html">std::vector::size</a></div><div class="ttdeci">T size(T... args)</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_ac83bcabf5a8db8b0d8d156a4c1bcd4c3_cgraph.svg" width="414" height="224"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6d3f2465a7c5803a1ff16c5378bcc5e4" name="a6d3f2465a7c5803a1ff16c5378bcc5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">&#9670;&#160;</a></span>construct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; range_queries::perSegTree::construct </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing the segment tree with the early passed vector. Every call creates a node to hold the sum of the given range, set its pointers to the children, and set its value to the sum of the children's values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the left index of the range that the created node holds its sum </td></tr>
    <tr><td class="paramname">j</td><td>the right index of the range that the created node holds its sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the newly created node </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  106</span>                                                                        {</div>
<div class="line"><span class="lineno">  107</span>        <span class="keyword">auto</span> newNode = std::make_shared&lt;Node&gt;(<a class="code hl_class" href="../../db/d8b/struct_node.html">Node</a>());</div>
<div class="line"><span class="lineno">  108</span>        <span class="keywordflow">if</span> (i == j) {</div>
<div class="line"><span class="lineno">  109</span>            newNode-&gt;val = <a class="code hl_variable" href="#a8ff495d2f389b4aaa54449c26c6078f3">vec</a>[i];</div>
<div class="line"><span class="lineno">  110</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  111</span>            uint32_t mid = i + (j - i) / 2;</div>
<div class="line"><span class="lineno">  112</span>            <span class="keyword">auto</span> leftt = <a class="code hl_function" href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">construct</a>(i, mid);</div>
<div class="line"><span class="lineno">  113</span>            <span class="keyword">auto</span> <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/manip/left.html">right</a> = <a class="code hl_function" href="#a6d3f2465a7c5803a1ff16c5378bcc5e4">construct</a>(mid + 1, j);</div>
<div class="line"><span class="lineno">  114</span>            newNode-&gt;val = leftt-&gt;val + <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/manip/left.html">right</a>-&gt;val;</div>
<div class="line"><span class="lineno">  115</span>            newNode-&gt;left = leftt;</div>
<div class="line"><span class="lineno">  116</span>            newNode-&gt;right = <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/manip/left.html">right</a>;</div>
<div class="line"><span class="lineno">  117</span>        }</div>
<div class="line"><span class="lineno">  118</span>        <span class="keywordflow">return</span> newNode;</div>
<div class="line"><span class="lineno">  119</span>    }</div>
<div class="ttc" id="aleft_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/manip/left.html">std::right</a></div><div class="ttdeci">T right(T... args)</div></div>
<div class="ttc" id="astruct_node_html"><div class="ttname"><a href="../../db/d8b/struct_node.html">Node</a></div><div class="ttdef"><b>Definition</b> linkedlist_implentation_usingarray.cpp:14</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_a6d3f2465a7c5803a1ff16c5378bcc5e4_cgraph.svg" width="188" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ace7f57935b3bb9446f11c239fd89ae79" name="ace7f57935b3bb9446f11c239fd89ae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7f57935b3bb9446f11c239fd89ae79">&#9670;&#160;</a></span>lazy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void range_queries::perSegTree::lazy </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>j</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>curr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If there is some value to be propagated to the passed node, value is added to the node and the children of the node, if exist, are copied and the propagated value is also added to them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the left index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">j</td><td>the right index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">curr</td><td>pointer to the node to be propagated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   84</span>                                               {</div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">if</span> (!curr-&gt;prop) {</div>
<div class="line"><span class="lineno">   86</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">   87</span>        }</div>
<div class="line"><span class="lineno">   88</span>        curr-&gt;val += (j - i + 1) * curr-&gt;prop;</div>
<div class="line"><span class="lineno">   89</span>        <span class="keywordflow">if</span> (i != j) {</div>
<div class="line"><span class="lineno">   90</span>            curr-&gt;left = <a class="code hl_function" href="#a0cec4b77d264521717cf9b0482c45817">newKid</a>(curr-&gt;left);</div>
<div class="line"><span class="lineno">   91</span>            curr-&gt;right = <a class="code hl_function" href="#a0cec4b77d264521717cf9b0482c45817">newKid</a>(curr-&gt;right);</div>
<div class="line"><span class="lineno">   92</span>            curr-&gt;left-&gt;prop += curr-&gt;prop;</div>
<div class="line"><span class="lineno">   93</span>            curr-&gt;right-&gt;prop += curr-&gt;prop;</div>
<div class="line"><span class="lineno">   94</span>        }</div>
<div class="line"><span class="lineno">   95</span>        curr-&gt;prop = 0;</div>
<div class="line"><span class="lineno">   96</span>    }</div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_a0cec4b77d264521717cf9b0482c45817"><div class="ttname"><a href="#a0cec4b77d264521717cf9b0482c45817">range_queries::perSegTree::newKid</a></div><div class="ttdeci">std::shared_ptr&lt; Node &gt; newKid(std::shared_ptr&lt; Node &gt; const &amp;curr)</div><div class="ttdoc">Creating a new node with the same values of curr node.</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:65</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_ace7f57935b3bb9446f11c239fd89ae79_cgraph.svg" width="414" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0cec4b77d264521717cf9b0482c45817" name="a0cec4b77d264521717cf9b0482c45817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cec4b77d264521717cf9b0482c45817">&#9670;&#160;</a></span>newKid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; range_queries::perSegTree::newKid </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>curr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating a new node with the same values of curr node. </p>
<p>values of the leaf nodes that the segment tree will be constructed with </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>node that would be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new node </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   65</span>                                                                {</div>
<div class="line"><span class="lineno">   66</span>        <span class="keyword">auto</span> newNode = std::make_shared&lt;Node&gt;(<a class="code hl_class" href="../../db/d8b/struct_node.html">Node</a>());</div>
<div class="line"><span class="lineno">   67</span>        newNode-&gt;left = curr-&gt;left;</div>
<div class="line"><span class="lineno">   68</span>        newNode-&gt;right = curr-&gt;right;</div>
<div class="line"><span class="lineno">   69</span>        newNode-&gt;prop = curr-&gt;prop;</div>
<div class="line"><span class="lineno">   70</span>        newNode-&gt;val = curr-&gt;val;</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">return</span> newNode;</div>
<div class="line"><span class="lineno">   72</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8ae4b1835e5e8aec32f68c5059ed4d4" name="ae8ae4b1835e5e8aec32f68c5059ed4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">&#9670;&#160;</a></span>query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t range_queries::perSegTree::query </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>j</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>curr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Querying the range from index l to index r, checking at every node if it has some value to be propagated. Current node's value is returned if its range is completely inside the wanted range, else 0 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the left index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">j</td><td>the right index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">l</td><td>the left index of the range whose sum should be returned as a result </td></tr>
    <tr><td class="paramname">r</td><td>the right index of the range whose sum should be returned as a result </td></tr>
    <tr><td class="paramname">curr</td><td>pointer to the current node, which has value = the sum of elements whose index x satisfies i&lt;=x&lt;=j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of elements whose index x satisfies l&lt;=x&lt;=r </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  172</span>                                                                      {</div>
<div class="line"><span class="lineno">  173</span>        <a class="code hl_function" href="#ace7f57935b3bb9446f11c239fd89ae79">lazy</a>(i, j, curr);</div>
<div class="line"><span class="lineno">  174</span>        <span class="keywordflow">if</span> (j &lt; l || r &lt; i) {</div>
<div class="line"><span class="lineno">  175</span>            <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  176</span>        }</div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {</div>
<div class="line"><span class="lineno">  178</span>            <span class="keywordflow">return</span> curr-&gt;val;</div>
<div class="line"><span class="lineno">  179</span>        }</div>
<div class="line"><span class="lineno">  180</span>        uint32_t mid = i + (j - i) / 2;</div>
<div class="line"><span class="lineno">  181</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">query</a>(i, mid, l, r, curr-&gt;left) +</div>
<div class="line"><span class="lineno">  182</span>               <a class="code hl_function" href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">query</a>(mid + 1, j, l, r, curr-&gt;right);</div>
<div class="line"><span class="lineno">  183</span>    }</div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_ace7f57935b3bb9446f11c239fd89ae79"><div class="ttname"><a href="#ace7f57935b3bb9446f11c239fd89ae79">range_queries::perSegTree::lazy</a></div><div class="ttdeci">void lazy(const uint32_t &amp;i, const uint32_t &amp;j, std::shared_ptr&lt; Node &gt; const &amp;curr)</div><div class="ttdoc">If there is some value to be propagated to the passed node, value is added to the node and the childr...</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:83</div></div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_ae8ae4b1835e5e8aec32f68c5059ed4d4"><div class="ttname"><a href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">range_queries::perSegTree::query</a></div><div class="ttdeci">int64_t query(const uint32_t &amp;i, const uint32_t &amp;j, const uint32_t &amp;l, const uint32_t &amp;r, std::shared_ptr&lt; Node &gt; const &amp;curr)</div><div class="ttdoc">Querying the range from index l to index r, checking at every node if it has some value to be propaga...</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:171</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_ae8ae4b1835e5e8aec32f68c5059ed4d4_cgraph.svg" width="639" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad484002bcb701820d55f32ea5d525571" name="ad484002bcb701820d55f32ea5d525571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad484002bcb701820d55f32ea5d525571">&#9670;&#160;</a></span>query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t range_queries::perSegTree::query </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>version</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Querying the range from index l to index r, getting the sum of the elements whose index x satisfies l&lt;=x&lt;=r. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the left index of the range whose sum should be returned as a result </td></tr>
    <tr><td class="paramname">r</td><td>the right index of the range whose sum should be returned as a result </td></tr>
    <tr><td class="paramname">version</td><td>the version to query on. If equals to 0, the original segment tree will be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of elements whose index x satisfies l&lt;=x&lt;=r </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  246</span>    {</div>
<div class="line"><span class="lineno">  247</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="#ae8ae4b1835e5e8aec32f68c5059ed4d4">query</a>(0, n - 1, l, r, <a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>[version]);</div>
<div class="line"><span class="lineno">  248</span>    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_ad484002bcb701820d55f32ea5d525571_cgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a0fe4e431f3e09c274ecd7d2d58dcb865" name="a0fe4e431f3e09c274ecd7d2d58dcb865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4e431f3e09c274ecd7d2d58dcb865">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t range_queries::perSegTree::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the number of versions after updates so far which is equal to the size of the pointers vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of versions </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  258</span>    {</div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a>();</div>
<div class="line"><span class="lineno">  260</span>    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_a0fe4e431f3e09c274ecd7d2d58dcb865_cgraph.svg" width="352" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a24487eda25123bc4d112e8430821a6c6" name="a24487eda25123bc4d112e8430821a6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24487eda25123bc4d112e8430821a6c6">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; range_queries::perSegTree::update </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>j</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>curr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doing range update, checking at every node if it has some value to be propagated. All nodes affected by the update are copied and propagation value is added to the leaf of them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the left index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">j</td><td>the right index of the range that the passed node holds its sum </td></tr>
    <tr><td class="paramname">l</td><td>the left index of the range to be updated </td></tr>
    <tr><td class="paramname">r</td><td>the right index of the range to be updated </td></tr>
    <tr><td class="paramname">value</td><td>the value to be added to every element whose index x satisfies l&lt;=x&lt;=r </td></tr>
    <tr><td class="paramname">curr</td><td>pointer to the current node, which has value = the sum of elements whose index x satisfies i&lt;=x&lt;=j </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current newly created node </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  138</span>                                                                  {</div>
<div class="line"><span class="lineno">  139</span>        <a class="code hl_function" href="#ace7f57935b3bb9446f11c239fd89ae79">lazy</a>(i, j, curr);</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {</div>
<div class="line"><span class="lineno">  141</span>            <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr&lt;Node&gt;</a> newNode = <a class="code hl_function" href="#a0cec4b77d264521717cf9b0482c45817">newKid</a>(curr);</div>
<div class="line"><span class="lineno">  142</span>            newNode-&gt;prop += value;</div>
<div class="line"><span class="lineno">  143</span>            <a class="code hl_function" href="#ace7f57935b3bb9446f11c239fd89ae79">lazy</a>(i, j, newNode);</div>
<div class="line"><span class="lineno">  144</span>            <span class="keywordflow">return</span> newNode;</div>
<div class="line"><span class="lineno">  145</span>        }</div>
<div class="line"><span class="lineno">  146</span>        <span class="keywordflow">if</span> (i &gt; r || j &lt; l) {</div>
<div class="line"><span class="lineno">  147</span>            <span class="keywordflow">return</span> curr;</div>
<div class="line"><span class="lineno">  148</span>        }</div>
<div class="line"><span class="lineno">  149</span>        <span class="keyword">auto</span> newNode = std::make_shared&lt;Node&gt;(<a class="code hl_class" href="../../db/d8b/struct_node.html">Node</a>());</div>
<div class="line"><span class="lineno">  150</span>        uint32_t mid = i + (j - i) / 2;</div>
<div class="line"><span class="lineno">  151</span>        newNode-&gt;left = <a class="code hl_function" href="#a24487eda25123bc4d112e8430821a6c6">update</a>(i, mid, l, r, value, curr-&gt;left);</div>
<div class="line"><span class="lineno">  152</span>        newNode-&gt;right = <a class="code hl_function" href="#a24487eda25123bc4d112e8430821a6c6">update</a>(mid + 1, j, l, r, value, curr-&gt;right);</div>
<div class="line"><span class="lineno">  153</span>        newNode-&gt;val = newNode-&gt;left-&gt;val + newNode-&gt;right-&gt;val;</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">return</span> newNode;</div>
<div class="line"><span class="lineno">  155</span>    }</div>
<div class="ttc" id="aclassrange__queries_1_1per_seg_tree_html_a24487eda25123bc4d112e8430821a6c6"><div class="ttname"><a href="#a24487eda25123bc4d112e8430821a6c6">range_queries::perSegTree::update</a></div><div class="ttdeci">std::shared_ptr&lt; Node &gt; update(const uint32_t &amp;i, const uint32_t &amp;j, const uint32_t &amp;l, const uint32_t &amp;r, const int64_t &amp;value, std::shared_ptr&lt; Node &gt; const &amp;curr)</div><div class="ttdoc">Doing range update, checking at every node if it has some value to be propagated. All nodes affected ...</div><div class="ttdef"><b>Definition</b> persistent_seg_tree_lazy_prop.cpp:135</div></div>
<div class="ttc" id="ashared_ptr_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_a24487eda25123bc4d112e8430821a6c6_cgraph.svg" width="639" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af87494e6cf012d28c4f5b9d1c15f9c5d" name="af87494e6cf012d28c4f5b9d1c15f9c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87494e6cf012d28c4f5b9d1c15f9c5d">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void range_queries::perSegTree::update </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Doing range update by passing the left and right indexes of the range as well as the value to be added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the left index of the range to be updated </td></tr>
    <tr><td class="paramname">r</td><td>the right index of the range to be updated </td></tr>
    <tr><td class="paramname">value</td><td>the value to be added to every element whose index x satisfies l&lt;=x&lt;=r </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  223</span>    {</div>
<div class="line"><span class="lineno">  224</span>        <a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">push_back</a>(<a class="code hl_function" href="#a24487eda25123bc4d112e8430821a6c6">update</a>(</div>
<div class="line"><span class="lineno">  225</span>            0, n - 1, l, r, value,</div>
<div class="line"><span class="lineno">  226</span>            <a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>[<a class="code hl_variable" href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">ptrs</a>.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a>() -</div>
<div class="line"><span class="lineno">  227</span>                 1]));  <span class="comment">// saving the root pointer to the new segment tree</span></div>
<div class="line"><span class="lineno">  228</span>    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d8/d28/classrange__queries_1_1per_seg_tree_af87494e6cf012d28c4f5b9d1c15f9c5d_cgraph.svg" width="100%" height="431"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1eac9cf0613dfc8e2b0195009dd5c9d5" name="a1eac9cf0613dfc8e2b0195009dd5c9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eac9cf0613dfc8e2b0195009dd5c9d5">&#9670;&#160;</a></span>ptrs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;<a class="el" href="../../d5/d66/classrange__queries_1_1per_seg_tree_1_1_node.html">Node</a>&gt; &gt; range_queries::perSegTree::ptrs {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of elements/leaf nodes in the segment tree </p>
<div class="fragment"><div class="line"><span class="lineno">   54</span>{};  <span class="comment">/// ptrs[i] holds a root pointer to the segment tree after the</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ff495d2f389b4aaa54449c26c6078f3" name="a8ff495d2f389b4aaa54449c26c6078f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff495d2f389b4aaa54449c26c6078f3">&#9670;&#160;</a></span>vec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;int64_t&gt; range_queries::perSegTree::vec {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ptrs[i] holds a root pointer to the segment tree after the ith update. ptrs[0] holds a root pointer to the segment tree before any updates </p>
<div class="fragment"><div class="line"><span class="lineno">   57</span>{};  <span class="comment">/// values of the leaf nodes that the segment</span></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>range_queries/<a class="el" href="../../d5/d58/persistent__seg__tree__lazy__prop_8cpp.html">persistent_seg_tree_lazy_prop.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dd/d69/namespacerange__queries.html">range_queries</a></li><li class="navelem"><a class="el" href="../../d8/d28/classrange__queries_1_1per_seg_tree.html">perSegTree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
