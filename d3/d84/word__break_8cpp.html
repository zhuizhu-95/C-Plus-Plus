<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TheAlgorithms/C++: dynamic_programming/word_break.cpp File Reference</title>
<link rel="icon" href="../../favicon.svg" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@xpack-3rd-party/doxygen-awesome-css@2.2.0-1/doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../project_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">TheAlgorithms/C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">All the algorithms implemented in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d84/word__break_8cpp.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">word_break.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break Problem</a>  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for word_break.cpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d2/d73/word__break_8cpp__incl.svg" width="540" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="../../d3/d84/word__break_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/namespacedynamic__programming.html">dynamic_programming</a></td></tr>
<tr class="memdesc:dd/d24/namespacedynamic__programming"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Programming algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d53/namespaceword__break.html">word_break</a></td></tr>
<tr class="memdesc:d6/d53/namespaceword__break"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for <a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break</a> problem. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1cc9dd6e6190d10a010fdcdfe7a21a81" id="r_a1cc9dd6e6190d10a010fdcdfe7a21a81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc9dd6e6190d10a010fdcdfe7a21a81">dynamic_programming::word_break::exists</a> (const std::string &amp;str, const std::unordered_set&lt; std::string &gt; &amp;strSet)</td></tr>
<tr class="memdesc:a1cc9dd6e6190d10a010fdcdfe7a21a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the string passed in param is present in the the unordered_set passed.  <br /></td></tr>
<tr class="separator:a1cc9dd6e6190d10a010fdcdfe7a21a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272b0f5cdb4e41fd6dee4538b808c06a" id="r_a272b0f5cdb4e41fd6dee4538b808c06a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a272b0f5cdb4e41fd6dee4538b808c06a">dynamic_programming::word_break::check</a> (const std::string &amp;s, const std::unordered_set&lt; std::string &gt; &amp;strSet, int pos, std::vector&lt; int &gt; *dp)</td></tr>
<tr class="memdesc:a272b0f5cdb4e41fd6dee4538b808c06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the string passed in param can be segmented from position 'pos', and then correctly go on to segment the rest of the string correctly as well to reach a solution.  <br /></td></tr>
<tr class="separator:a272b0f5cdb4e41fd6dee4538b808c06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4dcd6fd5282e535685361cba645d7c" id="r_afe4dcd6fd5282e535685361cba645d7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4dcd6fd5282e535685361cba645d7c">dynamic_programming::word_break::wordBreak</a> (const std::string &amp;s, const std::vector&lt; std::string &gt; &amp;wordDict)</td></tr>
<tr class="memdesc:afe4dcd6fd5282e535685361cba645d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the string passed in param can be segmented into the strings present in the vector. In others words, it checks if any permutation of strings in the vector can be concatenated to form the final string.  <br /></td></tr>
<tr class="separator:afe4dcd6fd5282e535685361cba645d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dca7b867074164d5f45b0f3851269d" id="r_aa8dca7b867074164d5f45b0f3851269d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8dca7b867074164d5f45b0f3851269d">test</a> ()</td></tr>
<tr class="memdesc:aa8dca7b867074164d5f45b0f3851269d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test implementations.  <br /></td></tr>
<tr class="separator:aa8dca7b867074164d5f45b0f3851269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function.  <br /></td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a href="https://leetcode.com/problems/word-break/" target="_blank">Word Break Problem</a> </p>
<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words.</p>
<p>Example 1: Input: s = "leetcode", wordDict = ["leet", "code"] Output: true Explanation: Return true because "leetcode" can be segmented as "leet code".</p>
<p>Example 2: Input: s = "applepenapple", wordDict = ["apple", "pen"] Output: true Explanation: Return true because "applepenapple" can be segmented as "apple
pen apple". Note that you are allowed to reuse a dictionary word.</p>
<p>Example 3: Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"] Output: false</p>
<dl class="section author"><dt>Author</dt><dd>[Akshay Anand] (<a href="https://github.com/axayjha">https://github.com/axayjha</a>) </dd></dl>

<p class="definition">Definition in file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a272b0f5cdb4e41fd6dee4538b808c06a" name="a272b0f5cdb4e41fd6dee4538b808c06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272b0f5cdb4e41fd6dee4538b808c06a">&#9670;&#160;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_programming::word_break::check </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>dp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that checks if the string passed in param can be segmented from position 'pos', and then correctly go on to segment the rest of the string correctly as well to reach a solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the complete string to be segmented </td></tr>
    <tr><td class="paramname">strSet</td><td>unordered set of string, that is to be used as the reference dictionary </td></tr>
    <tr><td class="paramname">pos</td><td>the index value at which we will segment string and test further if it is correctly segmented at pos </td></tr>
    <tr><td class="paramname">dp</td><td>the vector to memoize solution for each position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a valid solution/segmentation is possible by segmenting at index pos </dd>
<dd>
<code>false</code> otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d84/word__break_8cpp_source.html#l00080">80</a> of file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   81</span>                                        {</div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">if</span> (pos == s.length()) {</div>
<div class="line"><span class="lineno">   83</span>        <span class="comment">// if we have reached till the end of the string, means we have</span></div>
<div class="line"><span class="lineno">   84</span>        <span class="comment">// segmented throughout correctly hence we have a solution, thus</span></div>
<div class="line"><span class="lineno">   85</span>        <span class="comment">// returning true</span></div>
<div class="line"><span class="lineno">   86</span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   87</span>    }</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">if</span> (<a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>-&gt;at(pos) != INT_MAX) {</div>
<div class="line"><span class="lineno">   90</span>        <span class="comment">// if dp[pos] is not INT_MAX, means we must have saved a solution</span></div>
<div class="line"><span class="lineno">   91</span>        <span class="comment">// for the position pos; then return if the solution at pos is true</span></div>
<div class="line"><span class="lineno">   92</span>        <span class="comment">// or not</span></div>
<div class="line"><span class="lineno">   93</span>        <span class="keywordflow">return</span> <a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>-&gt;at(pos) == 1;</div>
<div class="line"><span class="lineno">   94</span>    }</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    std::string wordTillNow =</div>
<div class="line"><span class="lineno">   97</span>        <span class="stringliteral">&quot;&quot;</span>;  <span class="comment">// string to save the prefixes of word till different positons</span></div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = pos; i &lt; s.length(); i++) {</div>
<div class="line"><span class="lineno">  100</span>        <span class="comment">// Loop starting from pos to end, to check valid set of</span></div>
<div class="line"><span class="lineno">  101</span>        <span class="comment">// segmentations if any</span></div>
<div class="line"><span class="lineno">  102</span>        wordTillNow +=</div>
<div class="line"><span class="lineno">  103</span>            std::string(1, s[i]);  <span class="comment">// storing the prefix till the position i</span></div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>        <span class="comment">// if the prefix till current position is present in the dictionary</span></div>
<div class="line"><span class="lineno">  106</span>        <span class="comment">// and the remaining substring can also be segmented legally, then</span></div>
<div class="line"><span class="lineno">  107</span>        <span class="comment">// set solution at position pos in the memo, and return true</span></div>
<div class="line"><span class="lineno">  108</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="#a1cc9dd6e6190d10a010fdcdfe7a21a81">exists</a>(wordTillNow, strSet) &amp;&amp; check(s, strSet, i + 1, <a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>)) {</div>
<div class="line"><span class="lineno">  109</span>            <a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>-&gt;at(pos) = 1;</div>
<div class="line"><span class="lineno">  110</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  111</span>        }</div>
<div class="line"><span class="lineno">  112</span>    }</div>
<div class="line"><span class="lineno">  113</span>    <span class="comment">// if function has still not returned, then there must be no legal</span></div>
<div class="line"><span class="lineno">  114</span>    <span class="comment">// segmentation possible after segmenting at pos</span></div>
<div class="line"><span class="lineno">  115</span>    <a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>-&gt;at(pos) = 0;  <span class="comment">// so set solution at pos as false</span></div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;     <span class="comment">// and return no solution at position pos</span></div>
<div class="line"><span class="lineno">  117</span>}</div>
<div class="ttc" id="anamespacedp_html"><div class="ttname"><a href="../../df/d88/namespacedp.html">dp</a></div><div class="ttdoc">for std::vector</div><div class="ttdef"><b>Definition</b> <a href="../../de/d8c/partition__problem_8cpp_source.html#l00039">partition_problem.cpp:39</a></div></div>
<div class="ttc" id="aword__break_8cpp_html_a1cc9dd6e6190d10a010fdcdfe7a21a81"><div class="ttname"><a href="#a1cc9dd6e6190d10a010fdcdfe7a21a81">dynamic_programming::word_break::exists</a></div><div class="ttdeci">bool exists(const std::string &amp;str, const std::unordered_set&lt; std::string &gt; &amp;strSet)</div><div class="ttdoc">Function that checks if the string passed in param is present in the the unordered_set passed.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d84/word__break_8cpp_source.html#l00060">word_break.cpp:60</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cc9dd6e6190d10a010fdcdfe7a21a81" name="a1cc9dd6e6190d10a010fdcdfe7a21a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc9dd6e6190d10a010fdcdfe7a21a81">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_programming::word_break::exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strSet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that checks if the string passed in param is present in the the unordered_set passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be searched </td></tr>
    <tr><td class="paramname">strSet</td><td>unordered set of string, that is to be looked into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if str is present in strSet </dd>
<dd>
<code>false</code> if str is not present in strSet </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d84/word__break_8cpp_source.html#l00060">60</a> of file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   61</span>                                                       {</div>
<div class="line"><span class="lineno">   62</span>    <span class="keywordflow">return</span> strSet.find(str) != strSet.end();</div>
<div class="line"><span class="lineno">   63</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on exit </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d84/word__break_8cpp_source.html#l00174">174</a> of file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>           {</div>
<div class="line"><span class="lineno">  175</span>    <a class="code hl_function" href="#aa8dca7b867074164d5f45b0f3851269d">test</a>();  <span class="comment">// call the test function :)</span></div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>    <span class="comment">// the complete string</span></div>
<div class="line"><span class="lineno">  178</span>    <span class="keyword">const</span> std::string s = <span class="stringliteral">&quot;applepenapple&quot;</span>;</div>
<div class="line"><span class="lineno">  179</span>    <span class="comment">// the dictionary to be used</span></div>
<div class="line"><span class="lineno">  180</span>    <span class="keyword">const</span> std::vector&lt;std::string&gt; wordDict = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;pen&quot;</span>};</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>    <span class="comment">// should return true, as applepenapple can be segmented as apple + pen +</span></div>
<div class="line"><span class="lineno">  183</span>    <span class="comment">// apple</span></div>
<div class="line"><span class="lineno">  184</span>    std::cout &lt;&lt; <a class="code hl_function" href="#afe4dcd6fd5282e535685361cba645d7c">dynamic_programming::word_break::wordBreak</a>(s, wordDict)</div>
<div class="line"><span class="lineno">  185</span>              &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  186</span>}</div>
<div class="ttc" id="aword__break_8cpp_html_aa8dca7b867074164d5f45b0f3851269d"><div class="ttname"><a href="#aa8dca7b867074164d5f45b0f3851269d">test</a></div><div class="ttdeci">static void test()</div><div class="ttdoc">Test implementations.</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d84/word__break_8cpp_source.html#l00156">word_break.cpp:156</a></div></div>
<div class="ttc" id="aword__break_8cpp_html_afe4dcd6fd5282e535685361cba645d7c"><div class="ttname"><a href="#afe4dcd6fd5282e535685361cba645d7c">dynamic_programming::word_break::wordBreak</a></div><div class="ttdeci">bool wordBreak(const std::string &amp;s, const std::vector&lt; std::string &gt; &amp;wordDict)</div><div class="ttdoc">Function that checks if the string passed in param can be segmented into the strings present in the v...</div><div class="ttdef"><b>Definition</b> <a href="../../d3/d84/word__break_8cpp_source.html#l00131">word_break.cpp:131</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8dca7b867074164d5f45b0f3851269d" name="aa8dca7b867074164d5f45b0f3851269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dca7b867074164d5f45b0f3851269d">&#9670;&#160;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test implementations. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d84/word__break_8cpp_source.html#l00156">156</a> of file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  156</span>                   {</div>
<div class="line"><span class="lineno">  157</span>    <span class="comment">// the complete string</span></div>
<div class="line"><span class="lineno">  158</span>    <span class="keyword">const</span> std::string s = <span class="stringliteral">&quot;applepenapple&quot;</span>;</div>
<div class="line"><span class="lineno">  159</span>    <span class="comment">// the dictionary to be used</span></div>
<div class="line"><span class="lineno">  160</span>    <span class="keyword">const</span> std::vector&lt;std::string&gt; wordDict = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;pen&quot;</span>};</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span>    assert(dynamic_programming::word_break::wordBreak(s, wordDict));</div>
<div class="line"><span class="lineno">  163</span> </div>
<div class="line"><span class="lineno">  164</span>    <span class="comment">// should return true, as applepenapple can be segmented as apple + pen +</span></div>
<div class="line"><span class="lineno">  165</span>    <span class="comment">// apple</span></div>
<div class="line"><span class="lineno">  166</span>    std::cout &lt;&lt; <a class="code hl_function" href="#afe4dcd6fd5282e535685361cba645d7c">dynamic_programming::word_break::wordBreak</a>(s, wordDict)</div>
<div class="line"><span class="lineno">  167</span>              &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  168</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Test implementation passed!\n&quot;</span>;</div>
<div class="line"><span class="lineno">  169</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe4dcd6fd5282e535685361cba645d7c" name="afe4dcd6fd5282e535685361cba645d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4dcd6fd5282e535685361cba645d7c">&#9670;&#160;</a></span>wordBreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamic_programming::word_break::wordBreak </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wordDict</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that checks if the string passed in param can be segmented into the strings present in the vector. In others words, it checks if any permutation of strings in the vector can be concatenated to form the final string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the complete string to be segmented </td></tr>
    <tr><td class="paramname">wordDict</td><td>a vector of words to be used as dictionary to look into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if s can be formed by a combination of strings present in wordDict </dd>
<dd>
<code>false</code> otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d3/d84/word__break_8cpp_source.html#l00131">131</a> of file <a class="el" href="../../d3/d84/word__break_8cpp_source.html">word_break.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  131</span>                                                                         {</div>
<div class="line"><span class="lineno">  132</span>    <span class="comment">// unordered set to store words in the dictionary for constant time</span></div>
<div class="line"><span class="lineno">  133</span>    <span class="comment">// search</span></div>
<div class="line"><span class="lineno">  134</span>    std::unordered_set&lt;std::string&gt; strSet;</div>
<div class="line"><span class="lineno">  135</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : wordDict) {</div>
<div class="line"><span class="lineno">  136</span>        strSet.insert(s);</div>
<div class="line"><span class="lineno">  137</span>    }</div>
<div class="line"><span class="lineno">  138</span>    <span class="comment">// a vector to be used for memoization, whose value at index i will</span></div>
<div class="line"><span class="lineno">  139</span>    <span class="comment">// tell if the string s can be segmented (correctly) at position i.</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="comment">// initializing it with INT_MAX (which will denote no solution)</span></div>
<div class="line"><span class="lineno">  141</span>    std::vector&lt;int&gt; <a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>(s.length(), INT_MAX);</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="comment">// calling check method with position = 0, to check from left</span></div>
<div class="line"><span class="lineno">  144</span>    <span class="comment">// from where can be start segmenting the complete string in correct</span></div>
<div class="line"><span class="lineno">  145</span>    <span class="comment">// manner</span></div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">return</span> check(s, strSet, 0, &amp;<a class="code hl_namespace" href="../../df/d88/namespacedp.html">dp</a>);</div>
<div class="line"><span class="lineno">  147</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_8a20dd5bfd5341a725342bf72b6b686f.html">dynamic_programming</a></li><li class="navelem"><a class="el" href="../../d3/d84/word__break_8cpp.html">word_break.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
