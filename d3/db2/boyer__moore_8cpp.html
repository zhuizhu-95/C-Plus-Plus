<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms_in_C++: strings/boyer_moore.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algorithms_in_C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Set of algorithms implemented in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/db2/boyer__moore_8cpp.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">boyer_moore.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm" target="_blank">Boyer–Moore</a> algorithm searches for occurrences of pattern P in text T by performing explicit character comparisons at different alignments. Instead of a brute-force search of all alignments (of which there are n - m + 1), Boyer–Moore uses information gained by preprocessing P to skip as many alignments as possible.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for boyer_moore.cpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d1/db6/boyer__moore_8cpp__incl.svg" width="498" height="111"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">strings::boyer_moore::pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing all the data we need to search the preprocessed pattern in text.  <a href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:df/dcb/namespacestrings" id="r_df/dcb/namespacestrings"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dcb/namespacestrings.html">strings</a></td></tr>
<tr class="memdesc:df/dcb/namespacestrings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms with strings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a77c872c08612d7b8861ba13bc9881cbd" id="r_a77c872c08612d7b8861ba13bc9881cbd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c872c08612d7b8861ba13bc9881cbd">APLHABET_SIZE</a>&#160;&#160;&#160;CHAR_MAX</td></tr>
<tr class="memdesc:a77c872c08612d7b8861ba13bc9881cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of symbols in the alphabet we use  <br /></td></tr>
<tr class="separator:a77c872c08612d7b8861ba13bc9881cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa709cf7fca02b7d3e1888423d5f739a1" id="r_aa709cf7fca02b7d3e1888423d5f739a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa709cf7fca02b7d3e1888423d5f739a1">strings::boyer_moore::init_good_suffix</a> (const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;str, <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt; &amp;arg)</td></tr>
<tr class="memdesc:aa709cf7fca02b7d3e1888423d5f739a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that preprocess the good suffix thable.  <br /></td></tr>
<tr class="separator:aa709cf7fca02b7d3e1888423d5f739a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6688c9bb3e692297a3aa09cebc1c00" id="r_a2f6688c9bb3e692297a3aa09cebc1c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6688c9bb3e692297a3aa09cebc1c00">strings::boyer_moore::init_bad_char</a> (const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;str, <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt; &amp;arg)</td></tr>
<tr class="memdesc:a2f6688c9bb3e692297a3aa09cebc1c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that preprocess the bad char table.  <br /></td></tr>
<tr class="separator:a2f6688c9bb3e692297a3aa09cebc1c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b165af1dc341289fd705be4c67728f8" id="r_a0b165af1dc341289fd705be4c67728f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b165af1dc341289fd705be4c67728f8">strings::boyer_moore::init_pattern</a> (const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;str, <a class="el" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">pattern</a> &amp;arg)</td></tr>
<tr class="memdesc:a0b165af1dc341289fd705be4c67728f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that initializes pattern.  <br /></td></tr>
<tr class="separator:a0b165af1dc341289fd705be4c67728f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15703b553faed0d28202c10808cf9738" id="r_a15703b553faed0d28202c10808cf9738"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15703b553faed0d28202c10808cf9738">strings::boyer_moore::search</a> (const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;str, const <a class="el" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">pattern</a> &amp;arg)</td></tr>
<tr class="memdesc:a15703b553faed0d28202c10808cf9738"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that implements Boyer-Moore's algorithm.  <br /></td></tr>
<tr class="separator:a15703b553faed0d28202c10808cf9738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056122c8fe8fb0f5fca6428d3f7b5c3a" id="r_a056122c8fe8fb0f5fca6428d3f7b5c3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056122c8fe8fb0f5fca6428d3f7b5c3a">strings::boyer_moore::is_prefix</a> (const char *str, const char *pat, size_t len)</td></tr>
<tr class="memdesc:a056122c8fe8fb0f5fca6428d3f7b5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if pat is prefix of str.  <br /></td></tr>
<tr class="separator:a056122c8fe8fb0f5fca6428d3f7b5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8f69e7901ee7459d98bd4b9dda79d9" id="r_acb8f69e7901ee7459d98bd4b9dda79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb8f69e7901ee7459d98bd4b9dda79d9">and_test</a> (const char *text)</td></tr>
<tr class="memdesc:acb8f69e7901ee7459d98bd4b9dda79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test case in which we search for every appearance of the word 'and'.  <br /></td></tr>
<tr class="separator:acb8f69e7901ee7459d98bd4b9dda79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fac0dd4b19973da103a434143a16d2" id="r_ac8fac0dd4b19973da103a434143a16d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8fac0dd4b19973da103a434143a16d2">pat_test</a> (const char *text)</td></tr>
<tr class="memdesc:ac8fac0dd4b19973da103a434143a16d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test case in which we search for every appearance of the word 'pat'.  <br /></td></tr>
<tr class="separator:ac8fac0dd4b19973da103a434143a16d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483bb8ccf42aaf7375a83e91490eda1e" id="r_a483bb8ccf42aaf7375a83e91490eda1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a483bb8ccf42aaf7375a83e91490eda1e">tests</a> ()</td></tr>
<tr class="memdesc:a483bb8ccf42aaf7375a83e91490eda1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-test implementations.  <br /></td></tr>
<tr class="separator:a483bb8ccf42aaf7375a83e91490eda1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function.  <br /></td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm" target="_blank">Boyer–Moore</a> algorithm searches for occurrences of pattern P in text T by performing explicit character comparisons at different alignments. Instead of a brute-force search of all alignments (of which there are n - m + 1), Boyer–Moore uses information gained by preprocessing P to skip as many alignments as possible. </p>
<p>The key insight in this algorithm is that if the end of the pattern is compared to the text, then jumps along the text can be made rather than checking every character of the text. The reason that this works is that in lining up the pattern against the text, the last character of the pattern is compared to the character in the text.</p>
<p>If the characters do not match, there is no need to continue searching backwards along the text. This leaves us with two cases.</p>
<p>Case 1: If the character in the text does not match any of the characters in the pattern, then the next character in the text to check is located m characters farther along the text, where m is the length of the pattern.</p>
<p>Case 2: If the character in the text is in the pattern, then a partial shift of the pattern along the text is done to line up along the matching character and the process is repeated.</p>
<p>There are two shift rules:</p>
<p>[The bad character rule] (<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_bad_character_rule">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_bad_character_rule</a>)</p>
<p>[The good suffix rule] (<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_good_suffix_rule">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm#The_good_suffix_rule</a>)</p>
<p>The shift rules are implemented as constant-time table lookups, using tables generated during the preprocessing of P. </p><dl class="section author"><dt>Author</dt><dd><a href="https://github.com/stoychoX" target="_blank">Stoycho Kyosev</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a77c872c08612d7b8861ba13bc9881cbd" name="a77c872c08612d7b8861ba13bc9881cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c872c08612d7b8861ba13bc9881cbd">&#9670;&#160;</a></span>APLHABET_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APLHABET_SIZE&#160;&#160;&#160;CHAR_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of symbols in the alphabet we use </p>
<p>for assert for CHAR_MAX macro for strlen for IO operations for <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> for <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb8f69e7901ee7459d98bd4b9dda79d9" name="acb8f69e7901ee7459d98bd4b9dda79d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8f69e7901ee7459d98bd4b9dda79d9">&#9670;&#160;</a></span>and_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void and_test </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A test case in which we search for every appearance of the word 'and'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The text in which we search for appearance of the word 'and' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  220</span>                                {</div>
<div class="line"><span class="lineno">  221</span>    <a class="code hl_struct" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">strings::boyer_moore::pattern</a> ands;</div>
<div class="line"><span class="lineno">  222</span>    <a class="code hl_function" href="#a0b165af1dc341289fd705be4c67728f8">strings::boyer_moore::init_pattern</a>(<span class="stringliteral">&quot;and&quot;</span>, ands);</div>
<div class="line"><span class="lineno">  223</span>    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> indexes = <a class="code hl_function" href="#a15703b553faed0d28202c10808cf9738">strings::boyer_moore::search</a>(text, ands);</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>    assert(indexes.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a>() == 2);</div>
<div class="line"><span class="lineno">  226</span>    assert(strings::boyer_moore::is_prefix(text + indexes[0], <span class="stringliteral">&quot;and&quot;</span>, 3));</div>
<div class="line"><span class="lineno">  227</span>    assert(strings::boyer_moore::is_prefix(text + indexes[1], <span class="stringliteral">&quot;and&quot;</span>, 3));</div>
<div class="line"><span class="lineno">  228</span>}</div>
<div class="ttc" id="aboyer__moore_8cpp_html_a0b165af1dc341289fd705be4c67728f8"><div class="ttname"><a href="#a0b165af1dc341289fd705be4c67728f8">strings::boyer_moore::init_pattern</a></div><div class="ttdeci">void init_pattern(const std::string &amp;str, pattern &amp;arg)</div><div class="ttdoc">A function that initializes pattern.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:153</div></div>
<div class="ttc" id="aboyer__moore_8cpp_html_a15703b553faed0d28202c10808cf9738"><div class="ttname"><a href="#a15703b553faed0d28202c10808cf9738">strings::boyer_moore::search</a></div><div class="ttdeci">std::vector&lt; size_t &gt; search(const std::string &amp;str, const pattern &amp;arg)</div><div class="ttdoc">A function that implements Boyer-Moore's algorithm.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:165</div></div>
<div class="ttc" id="asize_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/size.html">std::vector::size</a></div><div class="ttdeci">T size(T... args)</div></div>
<div class="ttc" id="astructstrings_1_1boyer__moore_1_1pattern_html"><div class="ttname"><a href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">strings::boyer_moore::pattern</a></div><div class="ttdoc">A structure representing all the data we need to search the preprocessed pattern in text.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:70</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_acb8f69e7901ee7459d98bd4b9dda79d9_cgraph.svg" width="246" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2f6688c9bb3e692297a3aa09cebc1c00" name="a2f6688c9bb3e692297a3aa09cebc1c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6688c9bb3e692297a3aa09cebc1c00">&#9670;&#160;</a></span>init_bad_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strings::boyer_moore::init_bad_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that preprocess the bad char table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string being preprocessed </td></tr>
    <tr><td class="paramname">arg</td><td>The bad char table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  138</span>                                                                 {</div>
<div class="line"><span class="lineno">  139</span>    arg.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/resize.html">resize</a>(<a class="code hl_define" href="#a77c872c08612d7b8861ba13bc9881cbd">APLHABET_SIZE</a>, str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>());</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>(); i++) {</div>
<div class="line"><span class="lineno">  142</span>        arg[str[i]] = str.length() - i - 1;</div>
<div class="line"><span class="lineno">  143</span>    }</div>
<div class="line"><span class="lineno">  144</span>}</div>
<div class="ttc" id="aboyer__moore_8cpp_html_a77c872c08612d7b8861ba13bc9881cbd"><div class="ttname"><a href="#a77c872c08612d7b8861ba13bc9881cbd">APLHABET_SIZE</a></div><div class="ttdeci">#define APLHABET_SIZE</div><div class="ttdoc">number of symbols in the alphabet we use</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:52</div></div>
<div class="ttc" id="aresize_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/resize.html">std::vector::resize</a></div><div class="ttdeci">T resize(T... args)</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_a2f6688c9bb3e692297a3aa09cebc1c00_cgraph.svg" width="328" height="92"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa709cf7fca02b7d3e1888423d5f739a1" name="aa709cf7fca02b7d3e1888423d5f739a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa709cf7fca02b7d3e1888423d5f739a1">&#9670;&#160;</a></span>init_good_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strings::boyer_moore::init_good_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that preprocess the good suffix thable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string being preprocessed </td></tr>
    <tr><td class="paramname">arg</td><td>The good suffix table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   89</span>                                                                    {</div>
<div class="line"><span class="lineno">   90</span>    arg.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/resize.html">resize</a>(str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">size</a>() + 1, 0);</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    <span class="comment">// border_pos[i] - the index of the longest proper suffix of str[i..] which</span></div>
<div class="line"><span class="lineno">   93</span>    <span class="comment">// is also a proper prefix.</span></div>
<div class="line"><span class="lineno">   94</span>    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> border_pos(str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">size</a>() + 1, 0);</div>
<div class="line"><span class="lineno">   95</span> </div>
<div class="line"><span class="lineno">   96</span>    <span class="keywordtype">size_t</span> current_char = str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>();</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>    <span class="keywordtype">size_t</span> border_index = str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>() + 1;</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>    border_pos[current_char] = border_index;</div>
<div class="line"><span class="lineno">  101</span> </div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordflow">while</span> (current_char &gt; 0) {</div>
<div class="line"><span class="lineno">  103</span>        <span class="keywordflow">while</span> (border_index &lt;= str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>() &amp;&amp;</div>
<div class="line"><span class="lineno">  104</span>               str[current_char - 1] != str[border_index - 1]) {</div>
<div class="line"><span class="lineno">  105</span>            <span class="keywordflow">if</span> (arg[border_index] == 0) {</div>
<div class="line"><span class="lineno">  106</span>                arg[border_index] = border_index - current_char;</div>
<div class="line"><span class="lineno">  107</span>            }</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>            border_index = border_pos[border_index];</div>
<div class="line"><span class="lineno">  110</span>        }</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>        current_char--;</div>
<div class="line"><span class="lineno">  113</span>        border_index--;</div>
<div class="line"><span class="lineno">  114</span>        border_pos[current_char] = border_index;</div>
<div class="line"><span class="lineno">  115</span>    }</div>
<div class="line"><span class="lineno">  116</span> </div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordtype">size_t</span> largest_border_index = border_pos[0];</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">size</a>(); i++) {</div>
<div class="line"><span class="lineno">  120</span>        <span class="keywordflow">if</span> (arg[i] == 0) {</div>
<div class="line"><span class="lineno">  121</span>            arg[i] = largest_border_index;</div>
<div class="line"><span class="lineno">  122</span>        }</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span>        <span class="comment">// If we go pass the largest border we find the next one as we iterate</span></div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">if</span> (i == largest_border_index) {</div>
<div class="line"><span class="lineno">  126</span>            largest_border_index = border_pos[largest_border_index];</div>
<div class="line"><span class="lineno">  127</span>        }</div>
<div class="line"><span class="lineno">  128</span>    }</div>
<div class="line"><span class="lineno">  129</span>}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_aa709cf7fca02b7d3e1888423d5f739a1_cgraph.svg" width="328" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0b165af1dc341289fd705be4c67728f8" name="a0b165af1dc341289fd705be4c67728f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b165af1dc341289fd705be4c67728f8">&#9670;&#160;</a></span>init_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strings::boyer_moore::init_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">pattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that initializes pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Text used for initialization </td></tr>
    <tr><td class="paramname">arg</td><td>Initialized structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  153</span>                                                      {</div>
<div class="line"><span class="lineno">  154</span>    arg.pat = str;</div>
<div class="line"><span class="lineno">  155</span>    <a class="code hl_function" href="#a2f6688c9bb3e692297a3aa09cebc1c00">init_bad_char</a>(str, arg.bad_char);</div>
<div class="line"><span class="lineno">  156</span>    <a class="code hl_function" href="#aa709cf7fca02b7d3e1888423d5f739a1">init_good_suffix</a>(str, arg.good_suffix);</div>
<div class="line"><span class="lineno">  157</span>}</div>
<div class="ttc" id="aboyer__moore_8cpp_html_a2f6688c9bb3e692297a3aa09cebc1c00"><div class="ttname"><a href="#a2f6688c9bb3e692297a3aa09cebc1c00">strings::boyer_moore::init_bad_char</a></div><div class="ttdeci">void init_bad_char(const std::string &amp;str, std::vector&lt; size_t &gt; &amp;arg)</div><div class="ttdoc">A function that preprocess the bad char table.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:138</div></div>
<div class="ttc" id="aboyer__moore_8cpp_html_aa709cf7fca02b7d3e1888423d5f739a1"><div class="ttname"><a href="#aa709cf7fca02b7d3e1888423d5f739a1">strings::boyer_moore::init_good_suffix</a></div><div class="ttdeci">void init_good_suffix(const std::string &amp;str, std::vector&lt; size_t &gt; &amp;arg)</div><div class="ttdoc">A function that preprocess the good suffix thable.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:89</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_a0b165af1dc341289fd705be4c67728f8_cgraph.svg" width="520" height="166"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a056122c8fe8fb0f5fca6428d3f7b5c3a" name="a056122c8fe8fb0f5fca6428d3f7b5c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056122c8fe8fb0f5fca6428d3f7b5c3a">&#9670;&#160;</a></span>is_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool strings::boyer_moore::is_prefix </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pat</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if pat is prefix of str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>pointer to some part of the input text. </td></tr>
    <tr><td class="paramname">pat</td><td>the searched pattern. </td></tr>
    <tr><td class="paramname">len</td><td>length of the searched pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if pat IS prefix of str. </dd>
<dd>
<code>false</code> if pat is NOT a prefix of str. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  200</span>                                                             {</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">if</span> (<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/byte/strlen.html">strlen</a>(str) &lt; len) {</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  203</span>    }</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; len; i++) {</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordflow">if</span> (str[i] != pat[i]) {</div>
<div class="line"><span class="lineno">  207</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  208</span>        }</div>
<div class="line"><span class="lineno">  209</span>    }</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  212</span>}</div>
<div class="ttc" id="astrlen_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/byte/strlen.html">std::strlen</a></div><div class="ttdeci">T strlen(T... args)</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_a056122c8fe8fb0f5fca6428d3f7b5c3a_cgraph.svg" width="155" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on exit </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  269</span>           {</div>
<div class="line"><span class="lineno">  270</span>    <a class="code hl_function" href="#a483bb8ccf42aaf7375a83e91490eda1e">tests</a>();  <span class="comment">// run self-test implementations</span></div>
<div class="line"><span class="lineno">  271</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  272</span>}</div>
<div class="ttc" id="aboyer__moore_8cpp_html_a483bb8ccf42aaf7375a83e91490eda1e"><div class="ttname"><a href="#a483bb8ccf42aaf7375a83e91490eda1e">tests</a></div><div class="ttdeci">static void tests()</div><div class="ttdoc">Self-test implementations.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:250</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.svg" width="442" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac8fac0dd4b19973da103a434143a16d2" name="ac8fac0dd4b19973da103a434143a16d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fac0dd4b19973da103a434143a16d2">&#9670;&#160;</a></span>pat_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pat_test </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A test case in which we search for every appearance of the word 'pat'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The text in which we search for appearance of the word 'pat' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  235</span>                                {</div>
<div class="line"><span class="lineno">  236</span>    <a class="code hl_struct" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">strings::boyer_moore::pattern</a> pat;</div>
<div class="line"><span class="lineno">  237</span>    <a class="code hl_function" href="#a0b165af1dc341289fd705be4c67728f8">strings::boyer_moore::init_pattern</a>(<span class="stringliteral">&quot;pat&quot;</span>, pat);</div>
<div class="line"><span class="lineno">  238</span>    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> indexes = <a class="code hl_function" href="#a15703b553faed0d28202c10808cf9738">strings::boyer_moore::search</a>(text, pat);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    assert(indexes.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/size.html">size</a>() == 6);</div>
<div class="line"><span class="lineno">  241</span> </div>
<div class="line"><span class="lineno">  242</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; currentIndex : indexes) {</div>
<div class="line"><span class="lineno">  243</span>        assert(strings::boyer_moore::is_prefix(text + currentIndex, <span class="stringliteral">&quot;pat&quot;</span>, 3));</div>
<div class="line"><span class="lineno">  244</span>    }</div>
<div class="line"><span class="lineno">  245</span>}</div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_ac8fac0dd4b19973da103a434143a16d2_cgraph.svg" width="243" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a15703b553faed0d28202c10808cf9738" name="a15703b553faed0d28202c10808cf9738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15703b553faed0d28202c10808cf9738">&#9670;&#160;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; size_t &gt; strings::boyer_moore::search </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d5a/structstrings_1_1boyer__moore_1_1pattern.html">pattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that implements Boyer-Moore's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Text we are seatching in. </td></tr>
    <tr><td class="paramname">arg</td><td>pattern structure containing the preprocessed pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indexes of the occurrences of pattern in text </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  165</span>                                                                   {</div>
<div class="line"><span class="lineno">  166</span>    <span class="keywordtype">size_t</span> index_position = arg.pat.size() - 1;</div>
<div class="line"><span class="lineno">  167</span>    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;size_t&gt;</a> index_storage;</div>
<div class="line"><span class="lineno">  168</span> </div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">while</span> (index_position &lt; str.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">length</a>()) {</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordtype">size_t</span> index_string = index_position;</div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordtype">int</span> index_pattern = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(arg.pat.size()) - 1;</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>        <span class="keywordflow">while</span> (index_pattern &gt;= 0 &amp;&amp;</div>
<div class="line"><span class="lineno">  174</span>               str[index_string] == arg.pat[index_pattern]) {</div>
<div class="line"><span class="lineno">  175</span>            --index_pattern;</div>
<div class="line"><span class="lineno">  176</span>            --index_string;</div>
<div class="line"><span class="lineno">  177</span>        }</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">if</span> (index_pattern &lt; 0) {</div>
<div class="line"><span class="lineno">  180</span>            index_storage.<a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">push_back</a>(index_position - arg.pat.length() + 1);</div>
<div class="line"><span class="lineno">  181</span>            index_position += arg.good_suffix[0];</div>
<div class="line"><span class="lineno">  182</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  183</span>            index_position += <a class="code hl_functionRef" target="_blank" href="http://en.cppreference.com/w/cpp/algorithm/max.html">std::max</a>(arg.bad_char[str[index_string]],</div>
<div class="line"><span class="lineno">  184</span>                                       arg.good_suffix[index_pattern + 1]);</div>
<div class="line"><span class="lineno">  185</span>        }</div>
<div class="line"><span class="lineno">  186</span>    }</div>
<div class="line"><span class="lineno">  187</span> </div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">return</span> index_storage;</div>
<div class="line"><span class="lineno">  189</span>}</div>
<div class="ttc" id="amax_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/algorithm/max.html">std::max</a></div><div class="ttdeci">T max(T... args)</div></div>
<div class="ttc" id="apush_back_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector/push_back.html">std::vector::push_back</a></div><div class="ttdeci">T push_back(T... args)</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_a15703b553faed0d28202c10808cf9738_cgraph.svg" width="356" height="135"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a483bb8ccf42aaf7375a83e91490eda1e" name="a483bb8ccf42aaf7375a83e91490eda1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483bb8ccf42aaf7375a83e91490eda1e">&#9670;&#160;</a></span>tests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tests </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Self-test implementations. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  250</span>                    {</div>
<div class="line"><span class="lineno">  251</span>    <span class="keyword">const</span> <span class="keywordtype">char</span>* text =</div>
<div class="line"><span class="lineno">  252</span>        <span class="stringliteral">&quot;When pat Mr. and Mrs. pat Dursley woke up on the dull, gray  \</span></div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">                            Tuesday our story starts, \</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">                there was nothing about pat the cloudy sky outside to pat suggest that\</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">                        strange and \</span></div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">                    mysterious things would pat soon be happening all pat over the \</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">                        country.&quot;</span>;</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    <a class="code hl_function" href="#acb8f69e7901ee7459d98bd4b9dda79d9">and_test</a>(text);</div>
<div class="line"><span class="lineno">  260</span>    <a class="code hl_function" href="#ac8fac0dd4b19973da103a434143a16d2">pat_test</a>(text);</div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>    <a class="code hl_classRef" target="_blank" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;All tests have successfully passed!\n&quot;</span>;</div>
<div class="line"><span class="lineno">  263</span>}</div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aboyer__moore_8cpp_html_ac8fac0dd4b19973da103a434143a16d2"><div class="ttname"><a href="#ac8fac0dd4b19973da103a434143a16d2">pat_test</a></div><div class="ttdeci">void pat_test(const char *text)</div><div class="ttdoc">A test case in which we search for every appearance of the word 'pat'.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:235</div></div>
<div class="ttc" id="aboyer__moore_8cpp_html_acb8f69e7901ee7459d98bd4b9dda79d9"><div class="ttname"><a href="#acb8f69e7901ee7459d98bd4b9dda79d9">and_test</a></div><div class="ttdeci">void and_test(const char *text)</div><div class="ttdoc">A test case in which we search for every appearance of the word 'and'.</div><div class="ttdef"><b>Definition</b> boyer_moore.cpp:220</div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d3/db2/boyer__moore_8cpp_a483bb8ccf42aaf7375a83e91490eda1e_cgraph.svg" width="344" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_73a3cc5065b223eb41b02873c0e19f0e.html">strings</a></li><li class="navelem"><a class="el" href="../../d3/db2/boyer__moore_8cpp.html">boyer_moore.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
