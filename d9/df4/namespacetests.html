<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TheAlgorithms/C++: tests Namespace Reference</title>
<link rel="icon" href="../../favicon.svg" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@xpack-3rd-party/doxygen-awesome-css@2.2.0-1/doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {},
    packages: ['base','configmacros','ams']
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../project_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">TheAlgorithms/C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">All the algorithms implemented in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/df4/namespacetests.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tests Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Testcases to check Union of Two Arrays.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d53/classtests_1_1_circular_linked_list.html">CircularLinkedList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that implements a Circular Linked List.  <a href="../../dc/d53/classtests_1_1_circular_linked_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7c/structtests_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d6/d7c/structtests_1_1_node.html" title="A Node struct that represents a single Node in a Binary Tree.">Node</a> struct that represents a single <a class="el" href="../../d6/d7c/structtests_1_1_node.html" title="A Node struct that represents a single Node in a Binary Tree.">Node</a> in a Binary Tree.  <a href="../../d6/d7c/structtests_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a167c24bd817469ae47358d12e034f2d5" id="r_a167c24bd817469ae47358d12e034f2d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a167c24bd817469ae47358d12e034f2d5">test1</a> ()</td></tr>
<tr class="memdesc:a167c24bd817469ae47358d12e034f2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check an simple case.  <br /></td></tr>
<tr class="separator:a167c24bd817469ae47358d12e034f2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd77344d4af8fd56d14a5cabbf2f669" id="r_abdd77344d4af8fd56d14a5cabbf2f669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd77344d4af8fd56d14a5cabbf2f669">test2</a> ()</td></tr>
<tr class="memdesc:abdd77344d4af8fd56d14a5cabbf2f669"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check an empty vector.  <br /></td></tr>
<tr class="separator:abdd77344d4af8fd56d14a5cabbf2f669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa515639572647508b94986489aab6d76" id="r_aa515639572647508b94986489aab6d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa515639572647508b94986489aab6d76">test3</a> ()</td></tr>
<tr class="memdesc:aa515639572647508b94986489aab6d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check an invalid shift value.  <br /></td></tr>
<tr class="separator:aa515639572647508b94986489aab6d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9769e44683dcb67fe1083ad91e134d" id="r_a2b9769e44683dcb67fe1083ad91e134d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b9769e44683dcb67fe1083ad91e134d">test4</a> ()</td></tr>
<tr class="memdesc:a2b9769e44683dcb67fe1083ad91e134d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check a very large input.  <br /></td></tr>
<tr class="separator:a2b9769e44683dcb67fe1083ad91e134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b81d7a1534216af6a36a80135beb86" id="r_af7b81d7a1534216af6a36a80135beb86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b81d7a1534216af6a36a80135beb86">test5</a> ()</td></tr>
<tr class="memdesc:af7b81d7a1534216af6a36a80135beb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check a shift of zero.  <br /></td></tr>
<tr class="separator:af7b81d7a1534216af6a36a80135beb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacafde185abd8670abee51157f273dc2" id="r_aacafde185abd8670abee51157f273dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacafde185abd8670abee51157f273dc2">test6</a> ()</td></tr>
<tr class="memdesc:aacafde185abd8670abee51157f273dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Test to check correct functionality with an array sorted using std::sort.  <br /></td></tr>
<tr class="separator:aacafde185abd8670abee51157f273dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6109193567a5b7e36a27f2b4865fce20" id="r_a6109193567a5b7e36a27f2b4865fce20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6109193567a5b7e36a27f2b4865fce20">print</a> (const std::vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr class="memdesc:a6109193567a5b7e36a27f2b4865fce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the values of a vector sequentially, ending with a newline character.  <br /></td></tr>
<tr class="separator:a6109193567a5b7e36a27f2b4865fce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce39cf843989a39811a49ebe29dd6d8" id="r_afce39cf843989a39811a49ebe29dd6d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a> (const std::vector&lt; int32_t &gt; &amp;array, size_t shift)</td></tr>
<tr class="memdesc:afce39cf843989a39811a49ebe29dd6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the given vector to the left by the shift amount and returns a new vector with the result. The original vector is not mutated.  <br /></td></tr>
<tr class="separator:afce39cf843989a39811a49ebe29dd6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6109193567a5b7e36a27f2b4865fce20" id="r_a6109193567a5b7e36a27f2b4865fce20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6109193567a5b7e36a27f2b4865fce20">print</a> (const std::vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr class="memdesc:a6109193567a5b7e36a27f2b4865fce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the values of a vector sequentially, ending with a newline character.  <br /></td></tr>
<tr class="separator:a6109193567a5b7e36a27f2b4865fce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfb8711f49e591eb168ccaa3df6fb86" id="r_a1bfb8711f49e591eb168ccaa3df6fb86"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bfb8711f49e591eb168ccaa3df6fb86">shift_right</a> (const std::vector&lt; int32_t &gt; &amp;array, size_t shift)</td></tr>
<tr class="memdesc:a1bfb8711f49e591eb168ccaa3df6fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the given vector to the right by the shift amount and returns a new vector with the result. The original vector is not mutated.  <br /></td></tr>
<tr class="separator:a1bfb8711f49e591eb168ccaa3df6fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf9a06f0c236c2d95c97e441ea2d12e" id="r_adaf9a06f0c236c2d95c97e441ea2d12e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaf9a06f0c236c2d95c97e441ea2d12e">get_intersection</a> (const std::vector&lt; int32_t &gt; &amp;first, const std::vector&lt; int32_t &gt; &amp;second)</td></tr>
<tr class="memdesc:adaf9a06f0c236c2d95c97e441ea2d12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the intersection of two sorted arrays, and returns them in a vector.  <br /></td></tr>
<tr class="separator:adaf9a06f0c236c2d95c97e441ea2d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6109193567a5b7e36a27f2b4865fce20" id="r_a6109193567a5b7e36a27f2b4865fce20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6109193567a5b7e36a27f2b4865fce20">print</a> (const std::vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr class="memdesc:a6109193567a5b7e36a27f2b4865fce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the values of a vector sequentially, ending with a newline character.  <br /></td></tr>
<tr class="separator:a6109193567a5b7e36a27f2b4865fce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8ff06a84b041457873840bf82e2d74" id="r_a2b8ff06a84b041457873840bf82e2d74"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b8ff06a84b041457873840bf82e2d74">get_union</a> (const std::vector&lt; int32_t &gt; &amp;first, const std::vector&lt; int32_t &gt; &amp;second)</td></tr>
<tr class="memdesc:a2b8ff06a84b041457873840bf82e2d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the union of two sorted arrays, and returns them in a vector.  <br /></td></tr>
<tr class="separator:a2b8ff06a84b041457873840bf82e2d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6109193567a5b7e36a27f2b4865fce20" id="r_a6109193567a5b7e36a27f2b4865fce20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6109193567a5b7e36a27f2b4865fce20">print</a> (const std::vector&lt; int32_t &gt; &amp;array)</td></tr>
<tr class="memdesc:a6109193567a5b7e36a27f2b4865fce20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the values of a vector sequentially, ending with a newline character.  <br /></td></tr>
<tr class="separator:a6109193567a5b7e36a27f2b4865fce20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Testcases to check Union of Two Arrays. </p>
<p>Testcases to check Reversal of Binary Tree.</p>
<p>Testcases to check intersection of Two Arrays.</p>
<p>Testcases to check Circular Linked List. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adaf9a06f0c236c2d95c97e441ea2d12e" name="adaf9a06f0c236c2d95c97e441ea2d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf9a06f0c236c2d95c97e441ea2d12e">&#9670;&#160;</a></span>get_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; operations_on_datastructures::get_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the intersection of two sorted arrays, and returns them in a vector. </p>
<p>An algorithm is used that compares the elements of the two vectors, incrementing the index of the smaller of the two. If the elements are the same, the element is appended to the result array to be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A std::vector of sorted integer values </td></tr>
    <tr><td class="paramname">second</td><td>A std::vector of sorted integer values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of the intersection of the two arrays, in ascending order </dd></dl>
<p>&lt; Vector to hold the intersection</p>
<p>&lt; Index for the first array</p>
<p>&lt; Index for the second array</p>
<p>&lt; Length of first array</p>
<p>&lt; Length of second array</p>
<p>&lt; Increment index of second array</p>
<p>&lt; Increment index of second array</p>
<p>&lt; Add the element if it is unique</p>
<p>&lt; Increment index of first array</p>
<p>&lt; Increment index of second array too</p>

<p class="definition">Definition at line <a class="el" href="../../de/dc5/intersection__of__two__arrays_8cpp_source.html#l00049">49</a> of file <a class="el" href="../../de/dc5/intersection__of__two__arrays_8cpp_source.html">intersection_of_two_arrays.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   50</span>                                                                        {</div>
<div class="line"><span class="lineno">   51</span>    std::vector&lt;int32_t&gt; res;         </div>
<div class="line"><span class="lineno">   52</span>    <span class="keywordtype">size_t</span> f_index = 0;               </div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordtype">size_t</span> s_index = 0;               </div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordtype">size_t</span> f_length = first.size();   </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordtype">size_t</span> s_length = second.size();  </div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">while</span> (f_index &lt; f_length &amp;&amp; s_index &lt; s_length) {</div>
<div class="line"><span class="lineno">   58</span>        <span class="keywordflow">if</span> (first[f_index] &lt; second[s_index]) {</div>
<div class="line"><span class="lineno">   59</span>            f_index++;  </div>
<div class="line"><span class="lineno">   60</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first[f_index] &gt; second[s_index]) {</div>
<div class="line"><span class="lineno">   61</span>            s_index++;  </div>
<div class="line"><span class="lineno">   62</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   63</span>            <span class="keywordflow">if</span> ((res.size() == 0) || (first[f_index] != res.back())) {</div>
<div class="line"><span class="lineno">   64</span>                res.push_back(</div>
<div class="line"><span class="lineno">   65</span>                    first[f_index]);  </div>
<div class="line"><span class="lineno">   66</span>            }</div>
<div class="line"><span class="lineno">   67</span>            f_index++;  </div>
<div class="line"><span class="lineno">   68</span>            s_index++;  </div>
<div class="line"><span class="lineno">   69</span>        }</div>
<div class="line"><span class="lineno">   70</span>    }</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">   72</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b8ff06a84b041457873840bf82e2d74" name="a2b8ff06a84b041457873840bf82e2d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8ff06a84b041457873840bf82e2d74">&#9670;&#160;</a></span>get_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; operations_on_datastructures::get_union </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the union of two sorted arrays, and returns them in a vector. </p>
<p>An algorithm is used that compares the elements of the two vectors, appending the one that has a lower value, and incrementing the index for that array. If one of the arrays reaches its end, all the elements of the other are appended to the resultant vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A std::vector of sorted integer values </td></tr>
    <tr><td class="paramname">second</td><td>A std::vector of sorted integer values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of the union of the two arrays, in ascending order </dd></dl>
<p>&lt; Vector to hold the union</p>
<p>&lt; Index for the first array</p>
<p>&lt; Index for the second array</p>
<p>&lt; Length of first array</p>
<p>&lt; Length of second array</p>
<p>&lt; Integer to store value of the next element</p>
<p>&lt; Append from first array</p>
<p>&lt; Increment index of second array</p>
<p>&lt; Append from second array</p>
<p>&lt; Increment index of second array</p>
<p>&lt; Element is the same in both</p>
<p>&lt; Increment index of first array</p>
<p>&lt; Increment index of second array too</p>
<p>&lt; Add the element if it is unique</p>
<p>&lt; Add remaining elements</p>
<p>&lt; Add the element if it is unique</p>
<p>&lt; Add remaining elements</p>
<p>&lt; Add the element if it is unique</p>

<p class="definition">Definition at line <a class="el" href="../../d8/d9c/union__of__two__arrays_8cpp_source.html#l00049">49</a> of file <a class="el" href="../../d8/d9c/union__of__two__arrays_8cpp_source.html">union_of_two_arrays.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   50</span>                                                                 {</div>
<div class="line"><span class="lineno">   51</span>    std::vector&lt;int32_t&gt; res;         </div>
<div class="line"><span class="lineno">   52</span>    <span class="keywordtype">size_t</span> f_index = 0;               </div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordtype">size_t</span> s_index = 0;               </div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordtype">size_t</span> f_length = first.size();   </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordtype">size_t</span> s_length = second.size();  </div>
<div class="line"><span class="lineno">   56</span>    int32_t next = 0;  </div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>    <span class="keywordflow">while</span> (f_index &lt; f_length &amp;&amp; s_index &lt; s_length) {</div>
<div class="line"><span class="lineno">   59</span>        <span class="keywordflow">if</span> (first[f_index] &lt; second[s_index]) {</div>
<div class="line"><span class="lineno">   60</span>            next = first[f_index];  </div>
<div class="line"><span class="lineno">   61</span>            f_index++;              </div>
<div class="line"><span class="lineno">   62</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first[f_index] &gt; second[s_index]) {</div>
<div class="line"><span class="lineno">   63</span>            next = second[s_index];  </div>
<div class="line"><span class="lineno">   64</span>            s_index++;               </div>
<div class="line"><span class="lineno">   65</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   66</span>            next = first[f_index];  </div>
<div class="line"><span class="lineno">   67</span>            f_index++;              </div>
<div class="line"><span class="lineno">   68</span>            s_index++;              </div>
<div class="line"><span class="lineno">   69</span>        }</div>
<div class="line"><span class="lineno">   70</span>        <span class="keywordflow">if</span> ((res.size() == 0) || (next != res.back())) {</div>
<div class="line"><span class="lineno">   71</span>            res.push_back(next);  </div>
<div class="line"><span class="lineno">   72</span>        }</div>
<div class="line"><span class="lineno">   73</span>    }</div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">while</span> (f_index &lt; f_length) {</div>
<div class="line"><span class="lineno">   75</span>        next = first[f_index];  </div>
<div class="line"><span class="lineno">   76</span>        <span class="keywordflow">if</span> ((res.size() == 0) || (next != res.back())) {</div>
<div class="line"><span class="lineno">   77</span>            res.push_back(next);  </div>
<div class="line"><span class="lineno">   78</span>        }</div>
<div class="line"><span class="lineno">   79</span>        f_index++;</div>
<div class="line"><span class="lineno">   80</span>    }</div>
<div class="line"><span class="lineno">   81</span>    <span class="keywordflow">while</span> (s_index &lt; s_length) {</div>
<div class="line"><span class="lineno">   82</span>        next = second[s_index];  </div>
<div class="line"><span class="lineno">   83</span>        <span class="keywordflow">if</span> ((res.size() == 0) || (next != res.back())) {</div>
<div class="line"><span class="lineno">   84</span>            res.push_back(next);  </div>
<div class="line"><span class="lineno">   85</span>        }</div>
<div class="line"><span class="lineno">   86</span>        s_index++;</div>
<div class="line"><span class="lineno">   87</span>    }</div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">   89</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6109193567a5b7e36a27f2b4865fce20" name="a6109193567a5b7e36a27f2b4865fce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6109193567a5b7e36a27f2b4865fce20">&#9670;&#160;</a></span>print() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the values of a vector sequentially, ending with a newline character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Reference to the array to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   29</span>                                            {</div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">for</span> (int32_t i : array) {</div>
<div class="line"><span class="lineno">   31</span>        std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;  </div>
<div class="line"><span class="lineno">   32</span>    }</div>
<div class="line"><span class="lineno">   33</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  </div>
<div class="line"><span class="lineno">   34</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6109193567a5b7e36a27f2b4865fce20" name="a6109193567a5b7e36a27f2b4865fce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6109193567a5b7e36a27f2b4865fce20">&#9670;&#160;</a></span>print() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the values of a vector sequentially, ending with a newline character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Reference to the array to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   29</span>                                            {</div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">for</span> (int32_t i : array) {</div>
<div class="line"><span class="lineno">   31</span>        std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;  </div>
<div class="line"><span class="lineno">   32</span>    }</div>
<div class="line"><span class="lineno">   33</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  </div>
<div class="line"><span class="lineno">   34</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6109193567a5b7e36a27f2b4865fce20" name="a6109193567a5b7e36a27f2b4865fce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6109193567a5b7e36a27f2b4865fce20">&#9670;&#160;</a></span>print() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the values of a vector sequentially, ending with a newline character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Reference to the array to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   29</span>                                            {</div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">for</span> (int32_t i : array) {</div>
<div class="line"><span class="lineno">   31</span>        std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;  </div>
<div class="line"><span class="lineno">   32</span>    }</div>
<div class="line"><span class="lineno">   33</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  </div>
<div class="line"><span class="lineno">   34</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6109193567a5b7e36a27f2b4865fce20" name="a6109193567a5b7e36a27f2b4865fce20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6109193567a5b7e36a27f2b4865fce20">&#9670;&#160;</a></span>print() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the values of a vector sequentially, ending with a newline character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Reference to the array to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>
<p>Print each value in the array</p>
<p>Print newline</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   29</span>                                            {</div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">for</span> (int32_t i : array) {</div>
<div class="line"><span class="lineno">   31</span>        std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;  </div>
<div class="line"><span class="lineno">   32</span>    }</div>
<div class="line"><span class="lineno">   33</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  </div>
<div class="line"><span class="lineno">   34</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afce39cf843989a39811a49ebe29dd6d8" name="afce39cf843989a39811a49ebe29dd6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce39cf843989a39811a49ebe29dd6d8">&#9670;&#160;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; operations_on_datastructures::shift_left </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the given vector to the left by the shift amount and returns a new vector with the result. The original vector is not mutated. </p>
<p>Shifts the values of the vector, by creating a new vector and adding values from the shift index to the end, then appending the rest of the elements from the start of the vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A reference to the input std::vector </td></tr>
    <tr><td class="paramname">shift</td><td>The amount to be shifted to the left </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector with the shifted values </dd></dl>
<p>&lt; We got an invalid shift, return empty array</p>
<p>&lt; Result array</p>
<p>&lt; Add values after the shift index</p>
<p>&lt; Add the values from the start</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00046">46</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   47</span>                                              {</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordflow">if</span> (array.size() &lt;= shift) {</div>
<div class="line"><span class="lineno">   49</span>        <span class="keywordflow">return</span> {};  </div>
<div class="line"><span class="lineno">   50</span>    }</div>
<div class="line"><span class="lineno">   51</span>    std::vector&lt;int32_t&gt; res(array.size());  </div>
<div class="line"><span class="lineno">   52</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = shift; i &lt; array.size(); i++) {</div>
<div class="line"><span class="lineno">   53</span>        res[i - shift] = array[i];  </div>
<div class="line"><span class="lineno">   54</span>    }</div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; shift; i++) {</div>
<div class="line"><span class="lineno">   56</span>        res[array.size() - shift + i] =</div>
<div class="line"><span class="lineno">   57</span>            array[i];  </div>
<div class="line"><span class="lineno">   58</span>    }</div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">   60</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bfb8711f49e591eb168ccaa3df6fb86" name="a1bfb8711f49e591eb168ccaa3df6fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfb8711f49e591eb168ccaa3df6fb86">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int32_t &gt; operations_on_datastructures::shift_right </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts the given vector to the right by the shift amount and returns a new vector with the result. The original vector is not mutated. </p>
<p>Shifts the values of the vector, by creating a new vector and adding values from the shift index to the end, then appending the rest of the elements to the start of the vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A reference to the input std::vector </td></tr>
    <tr><td class="paramname">shift</td><td>The amount to be shifted to the right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector with the shifted values </dd></dl>
<p>&lt; We got an invalid shift, return empty array</p>
<p>&lt; Result array</p>
<p>&lt; Add values after the shift index</p>
<p>&lt; Add the values from the start</p>

<p class="definition">Definition at line <a class="el" href="../../d6/d57/array__right__rotation_8cpp_source.html#l00047">47</a> of file <a class="el" href="../../d6/d57/array__right__rotation_8cpp_source.html">array_right_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   48</span>                                               {</div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">if</span> (array.size() &lt;= shift) {</div>
<div class="line"><span class="lineno">   50</span>        <span class="keywordflow">return</span> {};  </div>
<div class="line"><span class="lineno">   51</span>    }</div>
<div class="line"><span class="lineno">   52</span>    std::vector&lt;int32_t&gt; res(array.size());  </div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = shift; i &lt; array.size(); i++) {</div>
<div class="line"><span class="lineno">   54</span>        res[i] = array[i - shift];  </div>
<div class="line"><span class="lineno">   55</span>    }</div>
<div class="line"><span class="lineno">   56</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; shift; i++) {</div>
<div class="line"><span class="lineno">   57</span>        res[i] =</div>
<div class="line"><span class="lineno">   58</span>            array[array.size() - shift + i];  </div>
<div class="line"><span class="lineno">   59</span>    }</div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">   61</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a167c24bd817469ae47358d12e034f2d5" name="a167c24bd817469ae47358d12e034f2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167c24bd817469ae47358d12e034f2d5">&#9670;&#160;</a></span>test1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check an simple case. </p>
<p>&lt; Use the BinaryTree</p>
<p>A Test to check an edge case (two empty arrays)</p>
<p>A Test to check a single value.</p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>A Test to check an edge case (single element reversal) </p>
<p>&lt; Should print 3 4 5 1 2</p>
<p>&lt; Should print 4 5 1 2 3</p>
<p>&lt; Check if result is empty</p>
<p>&lt; Should only print newline</p>
<p>&lt; Check for equal sizes</p>
<p>&lt; Ensure that there is only one element</p>
<p>&lt; Check if both elements are same</p>
<p>&lt; Check if result is empty</p>
<p>&lt; Should only print newline</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00075">75</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   75</span>             {</div>
<div class="line"><span class="lineno">   76</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 1\n&quot;</span>;</div>
<div class="line"><span class="lineno">   77</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized arr = {1, 2, 3, 4, 5}\n&quot;</span>;</div>
<div class="line"><span class="lineno">   78</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {3, 4, 5, 1, 2}\n&quot;</span>;</div>
<div class="line"><span class="lineno">   79</span>    std::vector&lt;int32_t&gt; arr = {1, 2, 3, 4, 5};</div>
<div class="line"><span class="lineno">   80</span>    std::vector&lt;int32_t&gt; res = <a class="code hl_function" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a>(arr, 2);</div>
<div class="line"><span class="lineno">   81</span>    std::vector&lt;int32_t&gt; expected = {3, 4, 5, 1, 2};</div>
<div class="line"><span class="lineno">   82</span>    assert(res == expected);</div>
<div class="line"><span class="lineno">   83</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(res);  </div>
<div class="line"><span class="lineno">   84</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">   85</span>}</div>
<div class="ttc" id="anamespacetests_html_a6109193567a5b7e36a27f2b4865fce20"><div class="ttname"><a href="#a6109193567a5b7e36a27f2b4865fce20">tests::print</a></div><div class="ttdeci">void print(const std::vector&lt; int32_t &gt; &amp;array)</div><div class="ttdoc">Prints the values of a vector sequentially, ending with a newline character.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d14/array__left__rotation_8cpp_source.html#l00029">array_left_rotation.cpp:29</a></div></div>
<div class="ttc" id="anamespacetests_html_afce39cf843989a39811a49ebe29dd6d8"><div class="ttname"><a href="#afce39cf843989a39811a49ebe29dd6d8">tests::shift_left</a></div><div class="ttdeci">std::vector&lt; int32_t &gt; shift_left(const std::vector&lt; int32_t &gt; &amp;array, size_t shift)</div><div class="ttdoc">Shifts the given vector to the left by the shift amount and returns a new vector with the result....</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d14/array__left__rotation_8cpp_source.html#l00046">array_left_rotation.cpp:46</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abdd77344d4af8fd56d14a5cabbf2f669" name="abdd77344d4af8fd56d14a5cabbf2f669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd77344d4af8fd56d14a5cabbf2f669">&#9670;&#160;</a></span>test2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check an empty vector. </p>
<p>A Test to check an edge case (NULL root element)</p>
<p>A Test to check an edge case (one empty array)</p>
<p>A Test to check a few values.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>&lt; Should print empty newline</p>
<p>&lt; Check if result is equal to a</p>
<p>&lt; Should only print newline</p>
<p>&lt; Check for equal sizes</p>
<p>&lt; Ensure that there is only one element</p>
<p>&lt; Check if result is equal to b</p>
<p>&lt; Should print 2 3</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00090">90</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   90</span>             {</div>
<div class="line"><span class="lineno">   91</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 2\n&quot;</span>;</div>
<div class="line"><span class="lineno">   92</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized arr = {}\n&quot;</span>;</div>
<div class="line"><span class="lineno">   93</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {}\n&quot;</span>;</div>
<div class="line"><span class="lineno">   94</span>    std::vector&lt;int32_t&gt; arr = {};</div>
<div class="line"><span class="lineno">   95</span>    std::vector&lt;int32_t&gt; res = <a class="code hl_function" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a>(arr, 2);</div>
<div class="line"><span class="lineno">   96</span>    std::vector&lt;int32_t&gt; expected = {};</div>
<div class="line"><span class="lineno">   97</span>    assert(res == expected);</div>
<div class="line"><span class="lineno">   98</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(res);  </div>
<div class="line"><span class="lineno">   99</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">  100</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa515639572647508b94986489aab6d76" name="aa515639572647508b94986489aab6d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa515639572647508b94986489aab6d76">&#9670;&#160;</a></span>test3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test3 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check an invalid shift value. </p>
<p>A Test to check correct reversal of a Binary Tree.</p>
<p>A Test to check correct functionality with a simple test case.</p>
<p>A Test to check an input array.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>&lt; 7 &gt; 5</p>
<p>&lt; Should print empty newline</p>
<p>&lt; 7 &gt; 5</p>
<p>&lt; Should print empty newline</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 6</p>
<p>&lt; Check for equality</p>
<p>&lt; Check for equality</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 2 3 4 6</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00105">105</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  105</span>             {</div>
<div class="line"><span class="lineno">  106</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 3\n&quot;</span>;</div>
<div class="line"><span class="lineno">  107</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized arr = {1, 2, 3, 4, 5}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  108</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  109</span>    std::vector&lt;int32_t&gt; arr = {1, 2, 3, 4, 5};</div>
<div class="line"><span class="lineno">  110</span>    std::vector&lt;int32_t&gt; res = <a class="code hl_function" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a>(arr, 7);  </div>
<div class="line"><span class="lineno">  111</span>    std::vector&lt;int32_t&gt; expected = {};</div>
<div class="line"><span class="lineno">  112</span>    assert(res == expected);</div>
<div class="line"><span class="lineno">  113</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(res);  </div>
<div class="line"><span class="lineno">  114</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">  115</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b9769e44683dcb67fe1083ad91e134d" name="a2b9769e44683dcb67fe1083ad91e134d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9769e44683dcb67fe1083ad91e134d">&#9670;&#160;</a></span>test4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test4 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check a very large input. </p>
<p>A Test to check correct functionality with duplicate values.</p>
<p>A Test to check using a specific <a class="el" href="../../d6/d7c/structtests_1_1_node.html" title="A Node struct that represents a single Node in a Binary Tree.">Node</a> as the starting point.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>&lt; Should print {4, 6, ..., 420, 2}</p>
<p>&lt; Should print {420, 2, 4, ..., 418}</p>
<p>&lt; <a class="el" href="../../d6/d7c/structtests_1_1_node.html" title="A Node struct that represents a single Node in a Binary Tree.">Node</a> we will start printing from</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 4 6</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 2 3 4 6 7</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00120">120</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  120</span>             {</div>
<div class="line"><span class="lineno">  121</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 4\n&quot;</span>;</div>
<div class="line"><span class="lineno">  122</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized arr = {2, 4, ..., 420}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  123</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {4, 6, ..., 420, 2}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  124</span>    std::vector&lt;int32_t&gt; arr;</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 210; i++) {</div>
<div class="line"><span class="lineno">  126</span>        arr.push_back(i * 2);</div>
<div class="line"><span class="lineno">  127</span>    }</div>
<div class="line"><span class="lineno">  128</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(arr);</div>
<div class="line"><span class="lineno">  129</span>    std::vector&lt;int32_t&gt; res = <a class="code hl_function" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a>(arr, 1);</div>
<div class="line"><span class="lineno">  130</span>    std::vector&lt;int32_t&gt; expected;</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 210; i++) {</div>
<div class="line"><span class="lineno">  132</span>        expected.push_back(arr[i]);</div>
<div class="line"><span class="lineno">  133</span>    }</div>
<div class="line"><span class="lineno">  134</span>    expected.push_back(2);</div>
<div class="line"><span class="lineno">  135</span>    assert(res == expected);</div>
<div class="line"><span class="lineno">  136</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(res);  </div>
<div class="line"><span class="lineno">  137</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">  138</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af7b81d7a1534216af6a36a80135beb86" name="af7b81d7a1534216af6a36a80135beb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b81d7a1534216af6a36a80135beb86">&#9670;&#160;</a></span>test5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test5 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check a shift of zero. </p>
<p>A Test to check correct functionality with a harder test case.</p>
<p>A Test to check an empty list.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>&lt; Should print 1 2 3 4 5</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 2 3 4</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 1 2 3 4 5 6 7 9</p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html#l00143">143</a> of file <a class="el" href="../../d9/d14/array__left__rotation_8cpp_source.html">array_left_rotation.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  143</span>             {</div>
<div class="line"><span class="lineno">  144</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 5\n&quot;</span>;</div>
<div class="line"><span class="lineno">  145</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initialized arr = {1, 2, 3, 4, 5}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  146</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {1, 2, 3, 4, 5}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  147</span>    std::vector&lt;int32_t&gt; arr = {1, 2, 3, 4, 5};</div>
<div class="line"><span class="lineno">  148</span>    std::vector&lt;int32_t&gt; res = <a class="code hl_function" href="#afce39cf843989a39811a49ebe29dd6d8">shift_left</a>(arr, 0);</div>
<div class="line"><span class="lineno">  149</span>    assert(res == arr);</div>
<div class="line"><span class="lineno">  150</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(res);  </div>
<div class="line"><span class="lineno">  151</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">  152</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacafde185abd8670abee51157f273dc2" name="aacafde185abd8670abee51157f273dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacafde185abd8670abee51157f273dc2">&#9670;&#160;</a></span>test6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tests::test6 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Test to check correct functionality with an array sorted using std::sort. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>&lt; Sort vector a</p>
<p>&lt; Sort vector b</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 3 7</p>
<p>&lt; Sort vector a</p>
<p>&lt; Sort vector b</p>
<p>&lt; Check if result is correct</p>
<p>&lt; Should print 1 2 3 4 5 6 7 8 9 11</p>

<p class="definition">Definition at line <a class="el" href="../../de/dc5/intersection__of__two__arrays_8cpp_source.html#l00166">166</a> of file <a class="el" href="../../de/dc5/intersection__of__two__arrays_8cpp_source.html">intersection_of_two_arrays.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  166</span>             {</div>
<div class="line"><span class="lineno">  167</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST CASE 6\n&quot;</span>;</div>
<div class="line"><span class="lineno">  168</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Intialized a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2} &quot;</span>;</div>
<div class="line"><span class="lineno">  169</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;b = {11, 3, 7, 8, 6}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  170</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Expected result: {3, 7}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  171</span>    std::vector&lt;int32_t&gt; a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2};</div>
<div class="line"><span class="lineno">  172</span>    std::vector&lt;int32_t&gt; b = {11, 3, 7, 8, 6};</div>
<div class="line"><span class="lineno">  173</span>    std::sort(a.begin(), a.end());  </div>
<div class="line"><span class="lineno">  174</span>    std::sort(b.begin(), b.end());  </div>
<div class="line"><span class="lineno">  175</span>    std::vector&lt;int32_t&gt; <a class="code hl_function" href="../../de/dc3/fibonacci__sum_8cpp.html#aadb40ac4c74a7efc0680b83eeee138aa">result</a> = <a class="code hl_function" href="#adaf9a06f0c236c2d95c97e441ea2d12e">get_intersection</a>(a, b);</div>
<div class="line"><span class="lineno">  176</span>    std::vector&lt;int32_t&gt; expected = {3, 7};</div>
<div class="line"><span class="lineno">  177</span>    assert(result == expected);  </div>
<div class="line"><span class="lineno">  178</span>    <a class="code hl_function" href="#a6109193567a5b7e36a27f2b4865fce20">print</a>(result);               </div>
<div class="line"><span class="lineno">  179</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;TEST PASSED!\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">  180</span>}</div>
<div class="ttc" id="afibonacci__sum_8cpp_html_aadb40ac4c74a7efc0680b83eeee138aa"><div class="ttname"><a href="../../de/dc3/fibonacci__sum_8cpp.html#aadb40ac4c74a7efc0680b83eeee138aa">math::fibonacci_sum::result</a></div><div class="ttdeci">uint64_t result(uint64_t n)</div><div class="ttdef"><b>Definition</b> <a href="../../de/dc3/fibonacci__sum_8cpp_source.html#l00077">fibonacci_sum.cpp:77</a></div></div>
<div class="ttc" id="anamespacetests_html_adaf9a06f0c236c2d95c97e441ea2d12e"><div class="ttname"><a href="#adaf9a06f0c236c2d95c97e441ea2d12e">tests::get_intersection</a></div><div class="ttdeci">std::vector&lt; int32_t &gt; get_intersection(const std::vector&lt; int32_t &gt; &amp;first, const std::vector&lt; int32_t &gt; &amp;second)</div><div class="ttdoc">Gets the intersection of two sorted arrays, and returns them in a vector.</div><div class="ttdef"><b>Definition</b> <a href="../../de/dc5/intersection__of__two__arrays_8cpp_source.html#l00049">intersection_of_two_arrays.cpp:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/df4/namespacetests.html">tests</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
